{"meta":{"title":373616885,"subtitle":"373616885","description":"373616885","author":"qinjp","url":"https://373616885.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"代码优化之对for循环嵌套的优化","slug":"代码优化之对for循环嵌套的优化","date":"2021-09-26T17:06:45.498Z","updated":"2021-09-26T17:47:54.648Z","comments":true,"path":"2021/09/27/代码优化之对for循环嵌套的优化/","link":"","permalink":"https://373616885.github.io/blog/2021/09/27/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E5%AF%B9for%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"循环嵌套使用原则答：外大内小","text":"循环嵌套使用原则答：外大内小 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.qin;public class ForTest &#123; public static void main(String[] args) &#123; // 外大内小 outBigInsideSmall(); // 内大外小 insideBigOutSmall(); &#125; /** * 外大内小 */ public static void outBigInsideSmall() &#123; // 1. 测试外循环比内循环大 Long startTime = System.nanoTime(); for (int i = 0; i &lt; 10000000; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; &#125; &#125; Long endTime = System.nanoTime(); System.out.println(&quot;外大内小耗时： &quot; + (endTime - startTime)); &#125; /** * 内大外小 */ public static void insideBigOutSmall() &#123; // 1. 测试外循环比内循环小 Long startTime = System.nanoTime(); for (int i = 0; i &lt; 100; i++) &#123; for (int j = 0; j &lt; 10000000; j++) &#123; &#125; &#125; Long endTime = System.nanoTime(); System.out.println(&quot;内大外小耗时： &quot;+(endTime-startTime)); &#125;&#125; 外大内小耗时： 1965000 内大外小耗时： 9732100","categories":[],"tags":[]},{"title":"docker安装Ubuntu以及ssh连接","slug":"docker安装Ubuntu以及ssh连接","date":"2021-09-23T17:08:07.414Z","updated":"2021-09-26T17:51:46.147Z","comments":true,"path":"2021/09/24/docker安装Ubuntu以及ssh连接/","link":"","permalink":"https://373616885.github.io/blog/2021/09/24/docker%E5%AE%89%E8%A3%85Ubuntu%E4%BB%A5%E5%8F%8Assh%E8%BF%9E%E6%8E%A5/","excerpt":"docker安装Ubuntu以及ssh连接","text":"docker安装Ubuntu以及ssh连接 Windows的安装docker下载：https://www.docker.com/products/docker-desktop 拉取ubuntu1docker pull ubuntu:20.04 查看拉取是否成功1docker images 运行容器1docker run --name iubuntu -it -d -p 3316:22 ubuntu 查看是否运行成功1docker ps 安装ssh服务进入容器终端安装ssh服务1docker exec -it iubuntu /bin/bash 执行更新1apt-get update 安装ssh-client1apt-get install openssh-client 安装ssh-server1apt-get install openssh-server 启动ssh服务1/etc/init.d/ssh start 安装vim编辑器1apt-get install vim 编辑sshd_config文件1vim /etc/ssh/sshd_config 修改： PermitRootLogin yes Port 22 保存退出 ESC + : + WQ 重启ssh服务1service ssh restart 设置ssh密码1passwd root 查看容器的IP安装net-tools工具包1apt-get install net-tools 查看IP1ifconfig 退出1exit 保存刚刚修改的镜像1docker commit iubuntu ubuntu-qin:20.04 运行新的镜像1docker run --name ubuntu-qin -it -d -p 3316:22 ubuntu-qin:20.04 下载MobaXtermhttps://mobaxterm.mobatek.net/download-home-edition.html 链接IP: 127.0.0.1 port : 3316","categories":[],"tags":[]},{"title":"错误的优化原则-避免在循环体中创建对象","slug":"错误的优化原则-避免在循环体中创建对象","date":"2021-09-22T17:30:43.219Z","updated":"2021-09-22T17:33:19.514Z","comments":true,"path":"2021/09/23/错误的优化原则-避免在循环体中创建对象/","link":"","permalink":"https://373616885.github.io/blog/2021/09/23/%E9%94%99%E8%AF%AF%E7%9A%84%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99-%E9%81%BF%E5%85%8D%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%BD%93%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/","excerpt":"for 循环创建对象 变量声明在循环体内更好","text":"for 循环创建对象 变量声明在循环体内更好 Java优化编程的法则有一条 避免在循环体中创建对象,即使该对象占用内存空间不大 1234for (int i = 0; i &lt; 10000; ++i) &#123; Object obj = new Object(); System.out.println(&quot;obj= &quot;+ obj);&#125; 应该改成 123456Object obj = null;for (int i = 0; i &lt; 10000; ++i) &#123; obj = new Object(); System.out.println(&quot;obj= &quot;+ obj);&#125; 上面的优化原则是错误的循环外申明变量不但效率不会变高，在循环外申明变量，内存占用会更大！不但没有正面作用，反而有负面作用！ 原因： 将变量声明在循环体外的方式没能能节省点空间，反而多了3 bit（多了一行代码导致偏移量增加，还有定义的Slot 不能复用，循环体外作用域还在不能复用，循环体内作用域已经结束，可以复用里面的Slot ） 声明在循环体外部的变量，人为地将其的声明周期拉长了，数据有可能被自己不小心破坏了，隐性的bug增加，还有可能对其他变量命名带来冲突 增强for循环是循环体内声明变量的方式–官方推荐的遍历方式，为什么官方要推崇这种方式，不解释，jdk源码都是写在循环体内的，官方都这样写了，我们还需要纠结什么呢 测试代码12345678910111213141516171819202122package test;public class VariableInsideOutsideLoopTest &#123; public void outsideLoop() &#123; Object o; int i = 0; while (++i &lt; 100) &#123; o = new Object(); o.toString(); &#125; Object b = 1; &#125; public void intsideLoop() &#123; int i = 0; while (++i &lt; 100) &#123; Object o = new Object(); o.toString(); &#125; Object b = 1; &#125;&#125; 上面的代码编译成class，反编译出来的样子是这样的 123456789101112131415161718192021222324252627282930313233343536package test;public class VariableInsideOutsideLoopTest &#123; public VariableInsideOutsideLoopTest() &#123; &#125; public void outsideLoop() &#123; int i = 0; while(true) &#123; ++i; if(i &gt;= 100) &#123; Object b = 1; return; &#125; Object o = new Object(); o.toString(); &#125; &#125; public void intsideLoop() &#123; int i = 0; while(true) &#123; ++i; if(i &gt;= 100) &#123; Object b = 1; return; &#125; Object o = new Object(); o.toString(); &#125; &#125;&#125; 反编译出来的代码一模一样！！结论不言而喻 内存比较12345678910111213141516171819202122232425262728293031323334353637383940jdk 11 vm参数-Xlog:gc* public class Loop &#123; public void loop() &#123; Object o; int i = 0; while (++i &lt; 100) &#123; o = new Object(); o.toString(); &#125; &#125;&#125; 循环体外：[0.012s][info][gc,heap] Heap region size: 1M[0.016s][info][gc ] Using G1[0.016s][info][gc,heap,coops] Heap address: 0x0000000701000000, size: 4080 MB, Compressed Oops mode: Zero based, Oop shift amount: 3[0.193s][info][gc,heap,exit ] Heap[0.194s][info][gc,heap,exit ] garbage-first heap total 262144K, used 6144K [0x0000000701000000, 0x0000000800000000)[0.194s][info][gc,heap,exit ] region size 1024K, 8 young (8192K), 0 survivors (0K)[0.194s][info][gc,heap,exit ] Metaspace used 6476K, capacity 6511K, committed 6784K, reserved 1056768K[0.194s][info][gc,heap,exit ] class space used 556K, capacity 570K, committed 640K, reserved 1048576K public class Loop &#123; public void loop() &#123; int i = 0; while (++i &lt; 100) &#123; Object o = new Object(); o.toString(); &#125; &#125;&#125;循环体内[0.012s][info][gc,heap] Heap region size: 1M[0.016s][info][gc ] Using G1[0.016s][info][gc,heap,coops] Heap address: 0x0000000701000000, size: 4080 MB, Compressed Oops mode: Zero based, Oop shift amount: 3[0.193s][info][gc,heap,exit ] Heap[0.193s][info][gc,heap,exit ] garbage-first heap total 262144K, used 6144K [0x0000000701000000, 0x0000000800000000)[0.193s][info][gc,heap,exit ] region size 1024K, 8 young (8192K), 0 survivors (0K)[0.193s][info][gc,heap,exit ] Metaspace used 6466K, capacity 6511K, committed 6784K, reserved 1056768K[0.193s][info][gc,heap,exit ] class space used 555K, capacity 570K, committed 640K, reserved 1048576K 区别 注意：类名和方法名要一致，不然会出现一些差异 class space 循环体外比循环体内多了 1K （循环体外 多了一行代码） Metaspace 方法区： 循环体外比循环体内多了 10K 原因：循环体外和循环体内 o 这个变量 都用到了一个Slot ( 数组下标) （多了一行代码导致偏移量增加） 但 循环体外 作用域 [ 20, 20 + 8] （[Start,Start+Length]）偏移量 + 长度 循环体内 作用域 [ 20, 20 + 5] （[Start,Start+Length]）偏移量 + 长度 总结：都申请了一个Slot的空间（使用的空间一样）—循环体外多了一行代码导致导致偏移量增加–class内存增加 这影响很小，Metaspace 多了一点，但实际heap中还是用了一个Slot的空间 用 javap 寻找原因（个人猜测） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990javac -g:vars Loop.javajavap -v Loop /** * 循环体内 */public class Loop &#123; public void inp() &#123; int i = 0; while (++i &lt; 1000) &#123; Object o = new Object(); o.toString(); &#125; &#125;&#125; public void inp(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: sipush 1000 9: if_icmpge 28 12: new #2 // class java/lang/Object 15: dup 16: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 19: astore_2 20: aload_2 21: invokevirtual #3 // Method java/lang/Object.toString:()Ljava/lang/String; 24: pop 25: goto 2 28: return LocalVariableTable: Start Length Slot Name Signature 20 5 2 o Ljava/lang/Object; 0 29 0 this Lcom/example/demo/test/Loop; 2 27 1 i I StackMapTable: number_of_entries = 2 frame_type = 252 /* append */ offset_delta = 2 locals = [ int ] frame_type = 25 /* same */ /** * 循环体外 */ public class Loop &#123; public void out() &#123; Object o; int i = 0; while (++i &lt; 1000) &#123; o = new Object(); o.toString(); &#125; &#125;&#125; public void out(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: iconst_0 1: istore_2 2: iinc 2, 1 5: iload_2 6: sipush 1000 9: if_icmpge 28 12: new #2 // class java/lang/Object 15: dup 16: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 19: astore_1 20: aload_1 21: invokevirtual #3 // Method java/lang/Object.toString:()Ljava/lang/String; 24: pop 25: goto 2 28: return LocalVariableTable: Start Length Slot Name Signature 20 8 1 o Ljava/lang/Object; 0 29 0 this Lcom/example/demo/test/Loop; 2 27 2 i I StackMapTable: number_of_entries = 2 frame_type = 253 /* append */ offset_delta = 2 locals = [ top, int ] frame_type = 25 /* same */ 总结首先都用了一个Slot (4字节–4 * 8 bit =32位 1 byte = 8 bit) 循环体外 o 用了一个Slot里的 8 Length 循环体内 o 用了一个Slot里的 5 Length 这 o 变量的作用域少了3 Length 循环一次少移动3 bit ，1亿次少移动35M的空间 slot复用导致可能导致内存进一步减少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * @author qinjp * @date 2021/8/4 */public class Test &#123; public void outsideLoop() &#123; Object o; int i = 0; while (++i &lt; 100) &#123; o = new Object(); o.toString(); &#125; Object b = 1; &#125; public void intsideLoop() &#123; int i = 0; while (++i &lt; 100) &#123; Object o = new Object(); o.toString(); &#125; Object b = 1; &#125;&#125;javac -g:vars Test.javajavap -v Test public void outsideLoop(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=4, args_size=1 0: iconst_0 1: istore_2 2: iinc 2, 1 5: iload_2 6: bipush 100 8: if_icmpge 27 11: new #2 // class java/lang/Object 14: dup 15: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 18: astore_1 19: aload_1 20: invokevirtual #3 // Method java/lang/Object.toString:()Ljava/lang/String; 23: pop 24: goto 2 27: iconst_1 28: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 31: astore_3 32: return LocalVariableTable: Start Length Slot Name Signature 19 8 1 o Ljava/lang/Object; 0 33 0 this Lcom/example/demo/Test; 2 31 2 i I 32 1 3 b Ljava/lang/Object; StackMapTable: number_of_entries = 2 frame_type = 253 /* append */ offset_delta = 2 locals = [ top, int ] frame_type = 24 /* same */ public void intsideLoop(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: bipush 100 8: if_icmpge 27 11: new #2 // class java/lang/Object 14: dup 15: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 18: astore_2 19: aload_2 20: invokevirtual #3 // Method java/lang/Object.toString:()Ljava/lang/String; 23: pop 24: goto 2 27: iconst_1 28: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 31: astore_2 32: return LocalVariableTable: Start Length Slot Name Signature 19 5 2 o Ljava/lang/Object; 0 33 0 this Lcom/example/demo/Test; 2 31 1 i I 32 1 2 b Ljava/lang/Object; StackMapTable: number_of_entries = 2 frame_type = 252 /* append */ offset_delta = 2 locals = [ int ] frame_type = 24 /* same */ outsideLoop在stack frame中定义了4个slot, 而intsideLoop只定义了3个slot!!! outsideLoop中，变量o和b分别占用了不同的slot，在intsideLoop中，变量o和b复用一个slot outsideLoop的stack frame比intsideLoop多占用4个字节内存（一个slot占用4个字节） 由于在intsideLoop中，o和b复用了同一个slot，所以，当b使用slot 2的时候，这是变量o已经“不复存在”，所以o原来引用的对象就没有任何引用，它有可能立即被GC回收（注意是有可能，不是一定），腾出所占用heap内存。 intsideLoop存在可能，在某些时间点，使用的heap内存比outsideLoop少不少 这个例子中少的内存微不足道，但是假设这个方法执行时间很长，o引用的对象是一个大对象时，还是有那么点意义。 总结 变量声明在循环体内比循环体外更好","categories":[],"tags":[]},{"title":"Spring 升级到5.3.x之后，使用BeanUtils 导致性能下降，GC次数急剧增加，性能急剧下降","slug":"Spring 升级到5.3.x之后，使用BeanUtils 导致性能下降，GC次数急剧增加，性能急剧下降","date":"2021-09-22T14:07:03.730Z","updated":"2021-09-23T14:28:07.970Z","comments":true,"path":"2021/09/22/Spring 升级到5.3.x之后，使用BeanUtils 导致性能下降，GC次数急剧增加，性能急剧下降/","link":"","permalink":"https://373616885.github.io/blog/2021/09/22/Spring%20%E5%8D%87%E7%BA%A7%E5%88%B05.3.x%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8BeanUtils%20%E5%AF%BC%E8%87%B4%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%EF%BC%8CGC%E6%AC%A1%E6%95%B0%E6%80%A5%E5%89%A7%E5%A2%9E%E5%8A%A0%EF%BC%8C%E6%80%A7%E8%83%BD%E6%80%A5%E5%89%A7%E4%B8%8B%E9%99%8D/","excerpt":"Spring 升级到5.3.x之后，使用BeanUtils 会导致性能下降，GC次数急剧增加，性能急剧下降","text":"Spring 升级到5.3.x之后，使用BeanUtils 会导致性能下降，GC次数急剧增加，性能急剧下降 从 Spring 5.3.x 开始，BeanUtils 开始通过创建 ResolvableType这个 进行属性复制 Spring 5.3.x 版本的 对象复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private static void copyProperties(Object source, Object target, @Nullable Class&lt;?&gt; editable, @Nullable String... ignoreProperties) throws BeansException &#123; Assert.notNull(source, &quot;Source must not be null&quot;); Assert.notNull(target, &quot;Target must not be null&quot;); Class&lt;?&gt; actualEditable = target.getClass(); if (editable != null) &#123; if (!editable.isInstance(target)) &#123; throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() + &quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;); &#125; actualEditable = editable; &#125; PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable); List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null); for (PropertyDescriptor targetPd : targetPds) &#123; Method writeMethod = targetPd.getWriteMethod(); if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123; PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName()); if (sourcePd != null) &#123; Method readMethod = sourcePd.getReadMethod(); if (readMethod != null) &#123; // 这里每一个属性都进行 创建ResolvableType ，导致每次复制 会创建出来大量的 ResolvableType ResolvableType sourceResolvableType = ResolvableType.forMethodReturnType(readMethod); ResolvableType targetResolvableType = ResolvableType.forMethodParameter(writeMethod, 0); // Ignore generic types in assignable check if either ResolvableType has unresolvable generics. boolean isAssignable = (sourceResolvableType.hasUnresolvableGenerics() || targetResolvableType.hasUnresolvableGenerics() ? ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType()) : targetResolvableType.isAssignableFrom(sourceResolvableType)); if (isAssignable) &#123; try &#123; if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123; readMethod.setAccessible(true); &#125; Object value = readMethod.invoke(source); if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123; writeMethod.setAccessible(true); &#125; writeMethod.invoke(target, value); &#125; catch (Throwable ex) &#123; throw new FatalBeanException( &quot;Could not copy property &#x27;&quot; + targetPd.getName() + &quot;&#x27; from source to target&quot;, ex); &#125; &#125; &#125; &#125; &#125; &#125; &#125; spring-beans 5.2.16.RELEASE 的 对象复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static void copyProperties(Object source, Object target, @Nullable Class&lt;?&gt; editable, @Nullable String... ignoreProperties) throws BeansException &#123; Assert.notNull(source, &quot;Source must not be null&quot;); Assert.notNull(target, &quot;Target must not be null&quot;); Class&lt;?&gt; actualEditable = target.getClass(); if (editable != null) &#123; if (!editable.isInstance(target)) &#123; throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() + &quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;); &#125; actualEditable = editable; &#125; PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable); List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null); for (PropertyDescriptor targetPd : targetPds) &#123; Method writeMethod = targetPd.getWriteMethod(); if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123; PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName()); if (sourcePd != null) &#123; Method readMethod = sourcePd.getReadMethod(); if (readMethod != null &amp;&amp; ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) &#123; try &#123; if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123; readMethod.setAccessible(true); &#125; Object value = readMethod.invoke(source); if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123; writeMethod.setAccessible(true); &#125; writeMethod.invoke(target, value); &#125; catch (Throwable ex) &#123; throw new FatalBeanException( &quot;Could not copy property &#x27;&quot; + targetPd.getName() + &quot;&#x27; from source to target&quot;, ex); &#125; &#125; &#125; &#125; &#125; &#125; 原因Spring 5.3.x 开始，BeanUtils 开始通过创建 ResolvableType这个进行属性复制 每一个属性都进行 创建ResolvableType ，导致每次复制 会创建出来大量的 ResolvableType 最终导致 YoungGC 明显增高 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TestBean &#123; private Integer age; private String name; private String address; public TestBean() &#123; &#125; public TestBean(Integer age, String name, String address) &#123; this.age = age; this.name = name; this.address = address; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public static void main(String[] args) &#123; TestBean testBean1 = new TestBean(32, &quot;qinjp&quot;, &quot;东三巷&quot; ); TestBean testBean2 = new TestBean(); for (int i = 0; i &gt; -1; i++) &#123; BeanUtils.copyProperties(testBean1, testBean2); System.out.println(i); &#125; &#125; &#125;spring-beans 5.2.16.RELEASE 和 spring-beans 5.3.9 这两个依赖去执行这个代码&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt;&lt;/dependency&gt; VM 参数使用 1-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xmx32m 使用 EpsilonGC，也就是在堆内存满的时候，不执行 GC 最大堆内存是 32m 在内存耗尽之前，不同版本的 BeanUtils.copyProperties 分别能执行多少次 试验结果是： spring-beans 5.2.16.RELEASE 是 72456次， spring-beans 5.3.9 是 7474 次 耗時 123456789101112131415161718spring-beans 5.3.9StopWatch &#x27;&#x27;: running time = 19488899601 ns---------------------------------------------ns % Task name---------------------------------------------19488899601 100% 19488spring-beans 5.2.16.RELEASEStopWatch &#x27;&#x27;: running time = 1709024300 ns---------------------------------------------ns % Task name---------------------------------------------1709024300 100% 1709 spring-beans 5.3.9 耗時 19488 ms spring-beans 5.2.16.RELEASE 耗時 1709 ms 这是相当大的差距超十倍了啊 针对这个问题，spring-framework github 里有 Issue. https://github.com/spring-projects/spring-framework/issues/27246 解决BeanUtils.copyProperties 的地方，替换成使用 BeanCopier，并且封装了一个简单类： 1234567891011121314151617181920212223public class BeanUtils &#123; private static final Cache&lt;String, BeanCopier&gt; CACHE = Caffeine.newBuilder().build(); public static void copyProperties(Object source, Object target) &#123; Class&lt;?&gt; sourceClass = source.getClass(); Class&lt;?&gt; targetClass = target.getClass(); BeanCopier beanCopier = CACHE.get(sourceClass.getName() + &quot; to &quot; + targetClass.getName(), k -&gt; &#123; return BeanCopier.create(sourceClass, targetClass, false); &#125;); beanCopier.copy(source, target, null); &#125;&#125;耗时：性能相对最好StopWatch &#x27;&#x27;: running time = 1076779400 ns---------------------------------------------ns % Task name---------------------------------------------1076779400 100% 1076 或者 hutool 的 BeanUtil 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.12&lt;/version&gt;&lt;/dependency&gt;BeanUtil.copyProperties(testBean1, testBean2);思路缓存source和target 的 bean 属性信息 /** * Bean属性缓存&lt;br&gt; * 缓存用于防止多次反射造成的性能问题 * @author Looly * */public enum BeanDescCache &#123; INSTANCE; private final SimpleCache&lt;Class&lt;?&gt;, BeanDesc&gt; bdCache = new SimpleCache&lt;&gt;(); /** * 获得属性名和&#123;@link BeanDesc&#125;Map映射 * @param beanClass Bean的类 * @param supplier 对象不存在时创建对象的函数 * @return 属性名和&#123;@link BeanDesc&#125;映射 * @since 5.4.2 */ public BeanDesc getBeanDesc(Class&lt;?&gt; beanClass, Func0&lt;BeanDesc&gt; supplier)&#123; return bdCache.get(beanClass, supplier); &#125;&#125;然后循环执行public PropDesc setValue(Object bean, Object value) &#123; if (null != this.setter) &#123; ReflectUtil.invoke(bean, this.setter, value); &#125; else if (ModifierUtil.isPublic(this.field)) &#123; ReflectUtil.setFieldValue(bean, this.field, value); &#125; return this;&#125;hutool BeanUtil 耗时：StopWatch &#x27;&#x27;: running time = 8414185100 ns---------------------------------------------ns % Task name---------------------------------------------8414185100 100% 8414","categories":[],"tags":[]},{"title":"JOL：查看Java 对象布局、大小工具","slug":"查看Java 对象布局、大小工具","date":"2021-09-21T17:37:24.650Z","updated":"2021-09-22T14:40:58.454Z","comments":true,"path":"2021/09/22/查看Java 对象布局、大小工具/","link":"","permalink":"https://373616885.github.io/blog/2021/09/22/%E6%9F%A5%E7%9C%8BJava%20%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E3%80%81%E5%A4%A7%E5%B0%8F%E5%B7%A5%E5%85%B7/","excerpt":"12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.16&lt;/version&gt;&lt;/dependency&gt;","text":"12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.16&lt;/version&gt;&lt;/dependency&gt; 1System.out.println(ClassLayout.parseInstance(obj).toPrintable());","categories":[],"tags":[]},{"title":"hexo","slug":"hexo","date":"2021-09-21T15:56:32.576Z","updated":"2021-09-22T14:39:54.123Z","comments":true,"path":"2021/09/21/hexo/","link":"","permalink":"https://373616885.github.io/blog/2021/09/21/hexo/","excerpt":"","text":"1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 1$ hexo s -p 80","categories":[],"tags":[]}],"categories":[],"tags":[]}