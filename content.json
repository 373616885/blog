{"meta":{"title":373616885,"subtitle":"373616885","description":"373616885","author":"qinjp","url":"https://373616885.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"升级到Spring 5.3.x之后，使用BeanUtils 导致性能下降，GC次数急剧增加，性能急剧下降","slug":"beanUtils","date":"2021-09-22T14:07:03.730Z","updated":"2021-09-22T15:41:21.417Z","comments":true,"path":"2021/09/22/beanUtils/","link":"","permalink":"https://373616885.github.io/blog/2021/09/22/beanUtils/","excerpt":"Spring 升级到5.3.x之后，使用BeanUtils 导致性能下降，GC次数急剧增加，性能急剧下降","text":"Spring 升级到5.3.x之后，使用BeanUtils 导致性能下降，GC次数急剧增加，性能急剧下降 从 Spring 5.3.x 开始，BeanUtils 开始通过创建 ResolvableType这个 进行属性复制 Spring 5.3.x 版本的 对象复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private static void copyProperties(Object source, Object target, @Nullable Class&lt;?&gt; editable, @Nullable String... ignoreProperties) throws BeansException &#123; Assert.notNull(source, &quot;Source must not be null&quot;); Assert.notNull(target, &quot;Target must not be null&quot;); Class&lt;?&gt; actualEditable = target.getClass(); if (editable != null) &#123; if (!editable.isInstance(target)) &#123; throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() + &quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;); &#125; actualEditable = editable; &#125; PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable); List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null); for (PropertyDescriptor targetPd : targetPds) &#123; Method writeMethod = targetPd.getWriteMethod(); if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123; PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName()); if (sourcePd != null) &#123; Method readMethod = sourcePd.getReadMethod(); if (readMethod != null) &#123; // 这里每一个属性都进行 创建ResolvableType ，导致每次复制 会创建出来大量的 ResolvableType ResolvableType sourceResolvableType = ResolvableType.forMethodReturnType(readMethod); ResolvableType targetResolvableType = ResolvableType.forMethodParameter(writeMethod, 0); // Ignore generic types in assignable check if either ResolvableType has unresolvable generics. boolean isAssignable = (sourceResolvableType.hasUnresolvableGenerics() || targetResolvableType.hasUnresolvableGenerics() ? ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType()) : targetResolvableType.isAssignableFrom(sourceResolvableType)); if (isAssignable) &#123; try &#123; if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123; readMethod.setAccessible(true); &#125; Object value = readMethod.invoke(source); if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123; writeMethod.setAccessible(true); &#125; writeMethod.invoke(target, value); &#125; catch (Throwable ex) &#123; throw new FatalBeanException( &quot;Could not copy property &#x27;&quot; + targetPd.getName() + &quot;&#x27; from source to target&quot;, ex); &#125; &#125; &#125; &#125; &#125; &#125; &#125; spring-beans 5.2.16.RELEASE 的 对象复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static void copyProperties(Object source, Object target, @Nullable Class&lt;?&gt; editable, @Nullable String... ignoreProperties) throws BeansException &#123; Assert.notNull(source, &quot;Source must not be null&quot;); Assert.notNull(target, &quot;Target must not be null&quot;); Class&lt;?&gt; actualEditable = target.getClass(); if (editable != null) &#123; if (!editable.isInstance(target)) &#123; throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() + &quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;); &#125; actualEditable = editable; &#125; PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable); List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null); for (PropertyDescriptor targetPd : targetPds) &#123; Method writeMethod = targetPd.getWriteMethod(); if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123; PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName()); if (sourcePd != null) &#123; Method readMethod = sourcePd.getReadMethod(); if (readMethod != null &amp;&amp; ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) &#123; try &#123; if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123; readMethod.setAccessible(true); &#125; Object value = readMethod.invoke(source); if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123; writeMethod.setAccessible(true); &#125; writeMethod.invoke(target, value); &#125; catch (Throwable ex) &#123; throw new FatalBeanException( &quot;Could not copy property &#x27;&quot; + targetPd.getName() + &quot;&#x27; from source to target&quot;, ex); &#125; &#125; &#125; &#125; &#125; &#125; 原因Spring 5.3.x 开始，BeanUtils 开始通过创建 ResolvableType这个进行属性复制 每一个属性都进行 创建ResolvableType ，导致每次复制 会创建出来大量的 ResolvableType 最终导致 YoungGC 明显增高 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TestBean &#123; private Integer age; private String name; private String address; public TestBean() &#123; &#125; public TestBean(Integer age, String name, String address) &#123; this.age = age; this.name = name; this.address = address; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public static void main(String[] args) &#123; TestBean testBean1 = new TestBean(32, &quot;qinjp&quot;, &quot;东三巷&quot; ); TestBean testBean2 = new TestBean(); for (int i = 0; i &gt; -1; i++) &#123; BeanUtils.copyProperties(testBean1, testBean2); System.out.println(i); &#125; &#125; &#125;spring-beans 5.2.16.RELEASE 和 spring-beans 5.3.9 这两个依赖去执行这个代码&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt;&lt;/dependency&gt; VM 参数使用 1-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xmx32m 使用 EpsilonGC，也就是在堆内存满的时候，不执行 GC 最大堆内存是 32m 在内存耗尽之前，不同版本的 BeanUtils.copyProperties 分别能执行多少次 试验结果是： spring-beans 5.2.16.RELEASE 是 72456次， spring-beans 5.3.9 是 7474 次 耗時 123456789101112131415161718spring-beans 5.3.9StopWatch &#x27;&#x27;: running time = 19488899601 ns---------------------------------------------ns % Task name---------------------------------------------19488899601 100% 19488spring-beans 5.2.16.RELEASEStopWatch &#x27;&#x27;: running time = 1709024300 ns---------------------------------------------ns % Task name---------------------------------------------1709024300 100% 1709 spring-beans 5.3.9 耗時 19488 ms spring-beans 5.2.16.RELEASE 耗時 1709 ms 这是相当大的差距超十倍了啊 针对这个问题，spring-framework github 里有 Issue. https://github.com/spring-projects/spring-framework/issues/27246 解决BeanUtils.copyProperties 的地方，替换成使用 BeanCopier，并且封装了一个简单类： 1234567891011121314151617181920212223public class BeanUtils &#123; private static final Cache&lt;String, BeanCopier&gt; CACHE = Caffeine.newBuilder().build(); public static void copyProperties(Object source, Object target) &#123; Class&lt;?&gt; sourceClass = source.getClass(); Class&lt;?&gt; targetClass = target.getClass(); BeanCopier beanCopier = CACHE.get(sourceClass.getName() + &quot; to &quot; + targetClass.getName(), k -&gt; &#123; return BeanCopier.create(sourceClass, targetClass, false); &#125;); beanCopier.copy(source, target, null); &#125;&#125;耗时：性能相对最好StopWatch &#x27;&#x27;: running time = 1076779400 ns---------------------------------------------ns % Task name---------------------------------------------1076779400 100% 1076 或者 hutool 的 BeanUtil 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.12&lt;/version&gt;&lt;/dependency&gt;BeanUtil.copyProperties(testBean1, testBean2);思路缓存source和target 的 bean 属性信息 /** * Bean属性缓存&lt;br&gt; * 缓存用于防止多次反射造成的性能问题 * @author Looly * */public enum BeanDescCache &#123; INSTANCE; private final SimpleCache&lt;Class&lt;?&gt;, BeanDesc&gt; bdCache = new SimpleCache&lt;&gt;(); /** * 获得属性名和&#123;@link BeanDesc&#125;Map映射 * @param beanClass Bean的类 * @param supplier 对象不存在时创建对象的函数 * @return 属性名和&#123;@link BeanDesc&#125;映射 * @since 5.4.2 */ public BeanDesc getBeanDesc(Class&lt;?&gt; beanClass, Func0&lt;BeanDesc&gt; supplier)&#123; return bdCache.get(beanClass, supplier); &#125;&#125;然后循环执行public PropDesc setValue(Object bean, Object value) &#123; if (null != this.setter) &#123; ReflectUtil.invoke(bean, this.setter, value); &#125; else if (ModifierUtil.isPublic(this.field)) &#123; ReflectUtil.setFieldValue(bean, this.field, value); &#125; return this;&#125;hutool BeanUtil 耗时：StopWatch &#x27;&#x27;: running time = 8414185100 ns---------------------------------------------ns % Task name---------------------------------------------8414185100 100% 8414","categories":[],"tags":[]},{"title":"JOL：查看Java 对象布局、大小工具","slug":"jol-core","date":"2021-09-21T17:37:24.650Z","updated":"2021-09-22T14:40:58.454Z","comments":true,"path":"2021/09/22/jol-core/","link":"","permalink":"https://373616885.github.io/blog/2021/09/22/jol-core/","excerpt":"12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.16&lt;/version&gt;&lt;/dependency&gt;","text":"12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.16&lt;/version&gt;&lt;/dependency&gt; 1System.out.println(ClassLayout.parseInstance(obj).toPrintable());","categories":[],"tags":[]},{"title":"hexo","slug":"hexo","date":"2021-09-21T15:56:32.576Z","updated":"2021-09-22T14:39:54.123Z","comments":true,"path":"2021/09/21/hexo/","link":"","permalink":"https://373616885.github.io/blog/2021/09/21/hexo/","excerpt":"","text":"1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 1$ hexo s -p 80","categories":[],"tags":[]}],"categories":[],"tags":[]}